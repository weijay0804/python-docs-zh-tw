<!DOCTYPE html>

<html lang="zh-TW" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>pickle --- Python 物件序列化 &#8212; Python 3.13.1 說明文件</title><meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=80d5e7a1" />
    <link rel="stylesheet" type="text/css" href="../_static/pydoctheme.css?v=41b4f12d" />
    <link rel="stylesheet" type="text/css" href="../_static/sidebar-wrap.css?v=65806c5a" />
    <link id="pygments_dark_css" media="(prefers-color-scheme: dark)" rel="stylesheet" type="text/css" href="../_static/pygments_dark.css?v=b20cc3f5" />
    
    <script src="../_static/documentation_options.js?v=ad6313a7"></script>
    <script src="../_static/doctools.js?v=9bcbadda"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../_static/translations.js?v=cbf116e0"></script>
    
    <script src="../_static/sidebar.js"></script>
    
    <link rel="search" type="application/opensearchdescription+xml"
          title="在 Python 3.13.1 說明文件 中搜尋"
          href="../_static/opensearch.xml"/>
    <link rel="author" title="關於這些文件" href="../about.html" />
    <link rel="index" title="索引" href="../genindex.html" />
    <link rel="search" title="搜尋" href="../search.html" />
    <link rel="copyright" title="版權" href="../copyright.html" />
    <link rel="next" title="copyreg --- 註冊 pickle 支援函式" href="copyreg.html" />
    <link rel="prev" title="資料持久性 (Data Persistence)" href="persistence.html" />
    
    <link rel="canonical" href="https://docs.python.org/3/library/pickle.html" />
    
      
    

    
    <style>
      @media only screen {
        table.full-width-table {
            width: 100%;
        }
      }
    </style>
<link rel="stylesheet" href="../_static/pydoctheme_dark.css" media="(prefers-color-scheme: dark)" id="pydoctheme_dark_css">
    <link rel="shortcut icon" type="image/png" href="../_static/py.svg" />
            <script type="text/javascript" src="../_static/copybutton.js"></script>
            <script type="text/javascript" src="../_static/menu.js"></script>
            <script type="text/javascript" src="../_static/search-focus.js"></script>
            <script type="text/javascript" src="../_static/themetoggle.js"></script> 
            <script type="text/javascript" src="../_static/rtd_switcher.js"></script>
            <meta name="readthedocs-addons-api-version" content="1">

  </head>
<body>
<div class="mobile-nav">
    <input type="checkbox" id="menuToggler" class="toggler__input" aria-controls="navigation"
           aria-pressed="false" aria-expanded="false" role="button" aria-label="Menu" />
    <nav class="nav-content" role="navigation">
        <label for="menuToggler" class="toggler__label">
            <span></span>
        </label>
        <span class="nav-items-wrapper">
            <a href="https://www.python.org/" class="nav-logo">
                <img src="../_static/py.svg" alt="Python logo"/>
            </a>
            <span class="version_switcher_placeholder"></span>
            <form role="search" class="search" action="../search.html" method="get">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" class="search-icon">
                    <path fill-rule="nonzero" fill="currentColor" d="M15.5 14h-.79l-.28-.27a6.5 6.5 0 001.48-5.34c-.47-2.78-2.79-5-5.59-5.34a6.505 6.505 0 00-7.27 7.27c.34 2.8 2.56 5.12 5.34 5.59a6.5 6.5 0 005.34-1.48l.27.28v.79l4.25 4.25c.41.41 1.08.41 1.49 0 .41-.41.41-1.08 0-1.49L15.5 14zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z"></path>
                </svg>
                <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" />
                <input type="submit" value="前往"/>
            </form>
        </span>
    </nav>
    <div class="menu-wrapper">
        <nav class="menu" role="navigation" aria-label="main navigation">
            <div class="language_switcher_placeholder"></div>
            
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label>
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python 物件序列化</a><ul>
<li><a class="reference internal" href="#relationship-to-other-python-modules">和其他 Python 模組的關係</a><ul>
<li><a class="reference internal" href="#comparison-with-marshal">和 <code class="docutils literal notranslate"><span class="pre">marshal</span></code> 的比較</a></li>
<li><a class="reference internal" href="#comparison-with-json">和 <code class="docutils literal notranslate"><span class="pre">json</span></code> 的比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-stream-format">資料串流格式</a></li>
<li><a class="reference internal" href="#module-interface">模組介面</a><ul>
<li><a class="reference internal" href="#pickle.HIGHEST_PROTOCOL"><code class="docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a></li>
<li><a class="reference internal" href="#pickle.DEFAULT_PROTOCOL"><code class="docutils literal notranslate"><span class="pre">DEFAULT_PROTOCOL</span></code></a></li>
<li><a class="reference internal" href="#pickle.dump"><code class="docutils literal notranslate"><span class="pre">dump()</span></code></a></li>
<li><a class="reference internal" href="#pickle.dumps"><code class="docutils literal notranslate"><span class="pre">dumps()</span></code></a></li>
<li><a class="reference internal" href="#pickle.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#pickle.loads"><code class="docutils literal notranslate"><span class="pre">loads()</span></code></a></li>
<li><a class="reference internal" href="#pickle.PickleError"><code class="docutils literal notranslate"><span class="pre">PickleError</span></code></a></li>
<li><a class="reference internal" href="#pickle.PicklingError"><code class="docutils literal notranslate"><span class="pre">PicklingError</span></code></a></li>
<li><a class="reference internal" href="#pickle.UnpicklingError"><code class="docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler"><code class="docutils literal notranslate"><span class="pre">Pickler</span></code></a><ul>
<li><a class="reference internal" href="#pickle.Pickler.dump"><code class="docutils literal notranslate"><span class="pre">dump()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.persistent_id"><code class="docutils literal notranslate"><span class="pre">persistent_id()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.dispatch_table"><code class="docutils literal notranslate"><span class="pre">dispatch_table</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.reducer_override"><code class="docutils literal notranslate"><span class="pre">reducer_override()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.fast"><code class="docutils literal notranslate"><span class="pre">fast</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pickle.Unpickler"><code class="docutils literal notranslate"><span class="pre">Unpickler</span></code></a><ul>
<li><a class="reference internal" href="#pickle.Unpickler.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Unpickler.persistent_load"><code class="docutils literal notranslate"><span class="pre">persistent_load()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Unpickler.find_class"><code class="docutils literal notranslate"><span class="pre">find_class()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pickle.PickleBuffer"><code class="docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a><ul>
<li><a class="reference internal" href="#pickle.PickleBuffer.raw"><code class="docutils literal notranslate"><span class="pre">raw()</span></code></a></li>
<li><a class="reference internal" href="#pickle.PickleBuffer.release"><code class="docutils literal notranslate"><span class="pre">release()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#what-can-be-pickled-and-unpickled">哪些物件能或不能被封裝、拆封？</a></li>
<li><a class="reference internal" href="#pickling-class-instances">Pickling 類別實例</a><ul>
<li><a class="reference internal" href="#object.__getnewargs_ex__"><code class="docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a></li>
<li><a class="reference internal" href="#object.__getnewargs__"><code class="docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a></li>
<li><a class="reference internal" href="#object.__getstate__"><code class="docutils literal notranslate"><span class="pre">__getstate__()</span></code></a></li>
<li><a class="reference internal" href="#object.__setstate__"><code class="docutils literal notranslate"><span class="pre">__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#object.__reduce__"><code class="docutils literal notranslate"><span class="pre">__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#object.__reduce_ex__"><code class="docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a></li>
<li><a class="reference internal" href="#persistence-of-external-objects">外部物件持久化</a></li>
<li><a class="reference internal" href="#dispatch-tables">調度表</a></li>
<li><a class="reference internal" href="#handling-stateful-objects">處裡紀錄大量狀態的物件</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-reduction-for-types-functions-and-other-objects">針對型別、函數或特定物件定製縮減函數</a></li>
<li><a class="reference internal" href="#out-of-band-buffers">帶外（Out-of-band）資料緩衝區</a><ul>
<li><a class="reference internal" href="#provider-api">供給者 API</a></li>
<li><a class="reference internal" href="#consumer-api">消費者 API</a></li>
<li><a class="reference internal" href="#example">範例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#restricting-globals">限制全域物件</a></li>
<li><a class="reference internal" href="#performance">效能</a></li>
<li><a class="reference internal" href="#examples">範例</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="persistence.html"
                          title="上一章">資料持久性 (Data Persistence)</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="copyreg.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code> --- 註冊 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> 支援函式</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/pickle.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </nav>
    </div>
</div>

  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             accesskey="I">索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg --- 註冊 pickle 支援函式"
             accesskey="N">下一頁</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="資料持久性 (Data Persistence)"
             accesskey="P">上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" accesskey="U">資料持久性 (Data Persistence)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python 物件序列化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>    

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="module-pickle">
<span id="pickle-python-object-serialization"></span><h1><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python 物件序列化<a class="headerlink" href="#module-pickle" title="連結到這個標頭">¶</a></h1>
<p><strong>原始碼：</strong><a class="extlink-source reference external" href="https://github.com/python/cpython/tree/3.13/Lib/pickle.py">Lib/pickle.py</a></p>
<hr class="docutils" id="index-0" />
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組實作的是一個在二進位層級上對 Python 物件進行序列化（serialize）或去序列化（de-serialize）。<em>&quot;Pickling&quot;</em> 用於專門指摘將一個 Python 物件轉換為一個二進位串流的過程，<em>&quot;unpickling&quot;</em> 則相反，指的是將一個（來自 <a class="reference internal" href="../glossary.html#term-binary-file"><span class="xref std std-term">binary file</span></a> 或 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a> 的）二進位串流轉換回 Python 物件的過程。Pickling（和 unpickling）的過程也可能被稱作 &quot;serialization&quot;, &quot;marshalling,&quot; <a class="footnote-reference brackets" href="#id7" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a> 或 &quot;flattening&quot;。不過，為了避免混淆，本文件將統一稱作封裝（pickling）、拆封（unpickling）。</p>
<div class="admonition warning">
<p class="admonition-title">警告</p>
<p><code class="docutils literal notranslate"><span class="pre">pickle</span></code> 模組**並不安全**，切記只拆封你信任的資料。</p>
<p>pickle 封包是有可能被建立來在拆封的時候**執行任意惡意程式碼**的。絕對不要拆封任何你無法信任其來源、或可能被修改過的 pickle 封包。</p>
<p>建議你可以使用 <a class="reference internal" href="hmac.html#module-hmac" title="hmac: Keyed-Hashing for Message Authentication (HMAC) implementation"><code class="xref py py-mod docutils literal notranslate"><span class="pre">hmac</span></code></a> 模組來簽署這個封包，以確保其未被修改過。</p>
<p>如果你在處理不受信任的資料，其他比較安全的序列化格式（例如 <a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a>）可能會更適合。請參照 See <a class="reference internal" href="#comparison-with-json"><span class="std std-ref">和 json 的比較</span></a> 的說明。</p>
</div>
<section id="relationship-to-other-python-modules">
<h2>和其他 Python 模組的關係<a class="headerlink" href="#relationship-to-other-python-modules" title="連結到這個標頭">¶</a></h2>
<section id="comparison-with-marshal">
<h3>和 <code class="docutils literal notranslate"><span class="pre">marshal</span></code> 的比較<a class="headerlink" href="#comparison-with-marshal" title="連結到這個標頭">¶</a></h3>
<p>Python 有另一個比較原始的序列化模組叫 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a>，不過其設計目的是為了支援 Python 的預編譯功能 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 的運作。總地來說，請盡可能地使用 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a>，沒事不要用 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a>。</p>
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 和 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 有幾個明顯不同的地方：</p>
<ul>
<li><p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 會記住哪些物件已經被序列化過了，稍後再次參照到這個物件的時候才不會進行重複的序列化。<a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 沒有這個功能。</p>
<p>這對遞迴物件和物件共用都有影響。遞迴物件是指包含自我參照的物件。這些情況在 marshal 模組中不會被處理，若嘗試使用 marshal 處理遞迴物件會導致 Python 直譯器崩潰。物件共用發生在序列化的物件階層中、不同位置對同一物件有多個參照時。<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 只會儲存這個被參照的物件一次，並確保所有其他參照指向這個主要的版本。共用的物件會保持共用，這對於可變（mutable）物件來說非常重要。</p>
</li>
<li><p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 無法序列化使用者自訂的類別和的實例。<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 則可以讓使用者儲存並還原自訂的類別實例，前提是儲存時該類別的定義存在於與要被儲存的物件所在的模組中、且可以被引入（import）。</p></li>
<li><p><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 序列化格式無法保證能在不同版本的 Python 之間移植。因為其主要的作用是支援 <code class="file docutils literal notranslate"><span class="pre">.pyc</span></code> 檔案的運作，Python 的實作人員會在需要時實作無法前向相容的序列化方式。但只要選擇了相容的 pickle 協定，且處理了 Python 2 和 Python 3 之間的資料類型差異，<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 序列化協定能保證在不同 Python 版本間的相容性。</p></li>
</ul>
</section>
<section id="comparison-with-json">
<span id="id2"></span><h3>和 <code class="docutils literal notranslate"><span class="pre">json</span></code> 的比較<a class="headerlink" href="#comparison-with-json" title="連結到這個標頭">¶</a></h3>
<p>pickle 協定和 <a class="reference external" href="https://json.org">JSON (JavaScript Object Notation)</a> 有一些根本上的不同：</p>
<ul class="simple">
<li><p>JSON 以文字形式作為序列化的輸出（輸出 unicode 文字，但大多數又會被編碼為 <code class="docutils literal notranslate"><span class="pre">UTF-8</span></code>），而 pickle 則是以二進位形式作為序列化的輸出；</p></li>
<li><p>JSON 是人類可讀的，而 pickle 則無法；</p></li>
<li><p>JSON 具有高互通性（interoperability）且在 Python 以外的環境也被大量利用，但 pickle 只能在 Python 內使用。</p></li>
<li><p>預設狀態下的 JSON 只能紀錄一小部份的 Python 內建型別，且無法紀錄自訂類別；但透過 Python 的自省措施，pickle 可以紀錄絕大多數的 Python 型別（其他比較複雜的狀況也可以透過實作 <a class="reference internal" href="#pickle-inst"><span class="std std-ref">specific object APIs</span></a> 來解決）；</p></li>
<li><p>去序列化不安全的 JSON 不會產生任意程式執行的風險，但去序列化不安全的 pickle 會。</p></li>
</ul>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><a class="reference internal" href="json.html#module-json" title="json: Encode and decode the JSON format."><code class="xref py py-mod docutils literal notranslate"><span class="pre">json</span></code></a> module: 是標準函式庫的一部分，可讓使用者進行 JSON 的序列化與去序列化。</p>
</div>
</section>
</section>
<section id="data-stream-format">
<span id="pickle-protocols"></span><h2>資料串流格式<a class="headerlink" href="#data-stream-format" title="連結到這個標頭">¶</a></h2>
<p id="index-1"><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 使用的資料格式是針對 Python 而設計的。好處是他不會受到外部標準（像是 JSON，無法紀錄指標共用）的限制；不過這也代表其他不是 Python 的程式可能無法重建 pickle 封裝的 Python 物件。</p>
<p>以預設設定來說，<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 使用相對緊湊的二進位形式來儲存資料。如果你需要盡可能地縮小檔案大小，你可以<a class="reference internal" href="archiving.html"><span class="doc">壓縮</span></a>封裝的資料。</p>
<p><a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> 含有工具可分析 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 所產生的資料流。<a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> 的源始碼詳細地記載了所有 pickle 協定的操作碼（opcode）。</p>
<p>截至目前為止，共有六種不同版本的協定可用於封裝 pickle。數字越大版本代表你需要使用越新的 Python 版本來拆封相應的 pickle 封裝。</p>
<ul class="simple">
<li><p>版本 0 的協定是最初「人類可讀」的版本，且可以向前支援早期版本的 Python。</p></li>
<li><p>版本 1 的協定使用舊的二進位格式，一樣能向前支援早期版本的 Python。</p></li>
<li><p>版本 2 的協定在 Python 2.3 中初次被引入。其可提供更高效率的 <a class="reference internal" href="../glossary.html#term-new-style-class"><span class="xref std std-term">new-style classes</span></a> 封裝過程。請參閱 <span class="target" id="index-14"></span><a class="pep reference external" href="https://peps.python.org/pep-0307/"><strong>PEP 307</strong></a> 以了解版本 2 帶來的改進。</p></li>
<li><p>版本 3 的協定在 Python 3.0 被新增。現在能支援封裝 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 的物件且無法被 2.x 版本的 Python 拆封。在 3.0～3.7 的 Python 預設使用 3 版協定。</p></li>
<li><p>版本 4 的協定在 Python 3.4 被新增。現在能支援超大物件的封裝、更多種型別的物件以及針對部份資料格式的儲存進行最佳化。從 Python 3.8 起，預設使用第 4 版協定。請參閱 <span class="target" id="index-15"></span><a class="pep reference external" href="https://peps.python.org/pep-3154/"><strong>PEP 3154</strong></a> 以了解第 4 版協定改進的細節。</p></li>
<li><p>版本 5 的協定在 Python 3.8 被新增。現在能支援帶外資料（Out-of-band data）並加速帶內資料的處理速度。請參閱 <span class="target" id="index-16"></span><a class="pep reference external" href="https://peps.python.org/pep-0574/"><strong>PEP 574</strong></a> 以了解第 5 版協定改進的細節。</p></li>
</ul>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>資料序列化是一個比資料持久化更早出現的概念；雖然 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 可以讀寫檔案物件，但它並不處理命名持久物件的問題，也不處理對持久物件的並行存取、一個更棘手的問題。<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組可以將複雜物件轉換成位元組串流，也可以將位元組串流轉換回具有相同原始內部結構的物件。對這些位元組串流最常見的處理方式是將它們寫入檔案中，但也可以將它們透過網路傳送或儲存在一個資料庫中。<a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> 模組提供了一個簡單的介面來讓使用者在 DBM 風格的資料庫檔案中對物件進行封裝和拆封的操作。</p>
</div>
</section>
<section id="module-interface">
<h2>模組介面<a class="headerlink" href="#module-interface" title="連結到這個標頭">¶</a></h2>
<p>想要序列化一個物件，你只需要呼叫 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 函式。而當你想要去序列化一個資料流時，你只需要呼叫 <a class="reference internal" href="#pickle.loads" title="pickle.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 即可。不過，若你希望能各自對序列化和去序列化的過程中有更多的掌控度，你可以自訂一個 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 或 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 物件。</p>
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組提供以下常數：</p>
<dl class="py data">
<dt class="sig sig-object py" id="pickle.HIGHEST_PROTOCOL">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">HIGHEST_PROTOCOL</span></span><a class="headerlink" href="#pickle.HIGHEST_PROTOCOL" title="連結到這個定義">¶</a></dt>
<dd><p>一個整數，表示可使用的最高<a class="reference internal" href="#pickle-protocols"><span class="std std-ref">協定版本</span></a>。這個值可作為 <em>protocol</em> 的數值傳給 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> 和 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 函式以及 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 建構式。</p>
</dd></dl>

<dl class="py data">
<dt class="sig sig-object py" id="pickle.DEFAULT_PROTOCOL">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">DEFAULT_PROTOCOL</span></span><a class="headerlink" href="#pickle.DEFAULT_PROTOCOL" title="連結到這個定義">¶</a></dt>
<dd><p>一個整數，指示用於序列化的預設<a class="reference internal" href="#pickle-protocols"><span class="std std-ref">協定版本</span></a>。有可能小於 <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a>。目前的預設協定版本為 4，是在 Python 3.4 中首次引入的，且與先前版本不相容。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.0 版的變更: </span>預設協定版本為 3。</p>
</div>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>預設協定版本為 4。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組提供下列函式來簡化封裝的過程：</p>
<dl class="py function">
<dt class="sig sig-object py" id="pickle.dump">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.dump" title="連結到這個定義">¶</a></dt>
<dd><p>將被封裝成 pickle 形式的物件 <em>obj</em> 寫入到已開啟的<a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">file object</span></a> <em>file</em>。這等效於<code class="docutils literal notranslate"><span class="pre">Pickler(file,</span> <span class="pre">protocol).dump(obj)</span></code>。</p>
<p>引數 <em>file</em>、<em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的意義與 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 建構式中的相同。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增 <em>buffer_callback</em> 引數。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pickle.dumps">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">dumps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.dumps" title="連結到這個定義">¶</a></dt>
<dd><p>將被封裝為 pickle 形式的物件 <em>obj</em> 以 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 類別回傳，而非寫入進檔案。</p>
<p>引數 <em>protocol</em>、<em>fix_imports</em> 和 <em>buffer_callback</em> 的意義和 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 建構式中的相同。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增 <em>buffer_callback</em> 引數。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pickle.load">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.load" title="連結到這個定義">¶</a></dt>
<dd><p>從已開啟的 <a class="reference internal" href="../glossary.html#term-file-object"><span class="xref std std-term">檔案物件</span></a> <em>file</em> 中讀取已序列化的物件，並傳回其重建後的物件階層。這相當於呼叫 <code class="docutils literal notranslate"><span class="pre">Unpickler(file).load()</span></code>。</p>
<p>模組會自動偵測 pickle 封包所使用的協定版本，所以無須另外指定。超出 pickle 封包表示範圍的位元組將被忽略。</p>
<p>引數 <em>file</em>、<em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的意義和 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 建構式中的相同。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增 <em>buffer</em> 引數。</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="pickle.loads">
<span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">loads</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">/</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.loads" title="連結到這個定義">¶</a></dt>
<dd><p>回傳從 <em>data</em> 的 pickle 封包重建後的物件階層。<em>data</em> 必須是一個 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">bytes-like object</span></a>。</p>
<p>模組會自動偵測 pickle 封包所使用的協定版本，所以無須另外指定。超出 pickle 封包表示範圍的位元組將被忽略。</p>
<p>引數 <em>fix_imports</em>、<em>encoding</em>、<em>errors</em>、<em>strict</em> 和 <em>buffers</em> 的意義與 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 建構式所用的相同。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增 <em>buffer</em> 引數。</p>
</div>
</dd></dl>

<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組定義了以下三種例外：</p>
<dl class="py exception">
<dt class="sig sig-object py" id="pickle.PickleError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">PickleError</span></span><a class="headerlink" href="#pickle.PickleError" title="連結到這個定義">¶</a></dt>
<dd><p>繼承 <a class="reference internal" href="exceptions.html#Exception" title="Exception"><code class="xref py py-exc docutils literal notranslate"><span class="pre">Exception</span></code></a> 類別。一個在封裝或拆封時遭遇其他例外時通用的基底類別。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pickle.PicklingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">PicklingError</span></span><a class="headerlink" href="#pickle.PicklingError" title="連結到這個定義">¶</a></dt>
<dd><p>當 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 遭遇無法封裝物件時會引發的例外。繼承 <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PickleError</span></code></a> 類別。</p>
<p>請參閱 <a class="reference internal" href="#pickle-picklable"><span class="std std-ref">哪些物件能或不能被封裝、拆封？</span></a> 以了解哪些物件是可以被封裝的。</p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="pickle.UnpicklingError">
<em class="property"><span class="pre">exception</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">UnpicklingError</span></span><a class="headerlink" href="#pickle.UnpicklingError" title="連結到這個定義">¶</a></dt>
<dd><p>拆封物件時遇到問題（如資料毀損或違反安全性原則等）所引發的意外。繼承自 <a class="reference internal" href="#pickle.PickleError" title="pickle.PickleError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PickleError</span></code></a> 類別。</p>
<p>拆封的時候還是可能會遭遇其他不在此列的例外（例如：AttributeError、EOFError、ImportError、或 IndexError），請注意。</p>
</dd></dl>

<p>引入模組 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 時會帶來三個類別：<a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>、<a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a> 和 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a>：</p>
<dl class="py class">
<dt class="sig sig-object py" id="pickle.Pickler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">Pickler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">protocol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffer_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler" title="連結到這個定義">¶</a></dt>
<dd><p>接受一個用以寫入 pickle 資料流的二進位檔案。</p>
<p>可選引數 <em>protocol</em> 接受整數，用來要求封裝器（pickler）使用指定的協定；支援從 0 版起到 <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a> 版的協定。如未指定，則預設為 <a class="reference internal" href="#pickle.DEFAULT_PROTOCOL" title="pickle.DEFAULT_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">DEFAULT_PROTOCOL</span></code></a>。若指定了負數，則視為選擇 <a class="reference internal" href="#pickle.HIGHEST_PROTOCOL" title="pickle.HIGHEST_PROTOCOL"><code class="xref py py-data docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a>。</p>
<p>傳予引數 <em>file</em> 的物件必須支援可寫入單一位元組的 write() 方法。只要滿足此條件，傳入的物件可以是一個硬碟上二進位檔案、一個 <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 實例或任何其他滿足這個介面要求的物件。</p>
<p>若 <em>fix_imports</em> 設為 true 且 <em>protocol</em> 版本小於 3，本模組會嘗試將 Python 3 的新模組名稱轉換為 Python 2 所支援的舊名，以讓 Python 2 能正確地讀取此資料流。</p>
<p>如果 <em>buffer_callback</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> （預設值），緩衝區的視圖會作為 pickle 封裝串流的一部分被序列化進 <em>file</em> 中。</p>
<p>如果 <em>buffer_callback</em> 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，則它可以被多次呼叫並回傳一個緩衝區的視圖。如果回呼函式回傳一個假值（例如 <code class="docutils literal notranslate"><span class="pre">None</span></code>），則所給的緩衝區將被視為 <a class="reference internal" href="#pickle-oob"><span class="std std-ref">帶外資料</span></a>；否則，該緩衝區將被視為 pickle 串流的帶內資料被序列化。</p>
<p>如果 <em>buffer_callback</em> 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 且 <em>protocol</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code> 或小於 5 則會報錯。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增 <em>buffer_callback</em> 引數。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pickle.Pickler.dump">
<span class="sig-name descname"><span class="pre">dump</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler.dump" title="連結到這個定義">¶</a></dt>
<dd><p>將已封裝（pickled）的 <em>obj</em> 寫入已在建構式中開啟的對應檔案。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Pickler.persistent_id">
<span class="sig-name descname"><span class="pre">persistent_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler.persistent_id" title="連結到這個定義">¶</a></dt>
<dd><p>預設不進行任何動作。這是一種抽象方法，用於讓後續繼承這個類別的物件可以覆寫本方法函式。</p>
<p>如果 <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> 回傳 <code class="docutils literal notranslate"><span class="pre">None</span></code>，則 <em>obj</em> 會照一般的方式進行封裝（pickling）。若回傳其他值，則 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 會將該值作為 <em>obj</em> 的永久識別碼回傳。此永久識別碼的意義應由 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.persistent_load()</span></code></a> 定義。請注意 <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> 回傳的值本身不能擁有自己的永久識別碼。</p>
<p>關於細節與用法範例請見 <a class="reference internal" href="#pickle-persistent"><span class="std std-ref">外部物件持久化</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版的變更: </span>在 C 的 <code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code> 實作中的增加了這個方法的預設實作。</p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pickle.Pickler.dispatch_table">
<span class="sig-name descname"><span class="pre">dispatch_table</span></span><a class="headerlink" href="#pickle.Pickler.dispatch_table" title="連結到這個定義">¶</a></dt>
<dd><p>封裝器（pickler）物件含有的的調度表是一個 <em>縮減函式</em> （reduction function）的註冊表，可以使用 <a class="reference internal" href="copyreg.html#copyreg.pickle" title="copyreg.pickle"><code class="xref py py-func docutils literal notranslate"><span class="pre">copyreg.pickle()</span></code></a> 來宣告這類縮減函式。它是一個以類別為鍵、還原函式為值的映射表。縮減函式應準備接收一個對應類別的引數，並應遵循與 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 方法相同的介面。</p>
<p>預設情況下，封裝器（pickler）物件不會有 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 屬性，而是會使用由 <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 模組管理的全域調度表。不過，若要自訂某個封裝器（pickler）物件的序列化行為，可以將 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 屬性設置為類字典物件。另外，如果 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 的子類別具有 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 屬性，那麼這個屬性將作為該子類別實例的預設調度表。</p>
<p>關於用法範例請見 <a class="reference internal" href="#pickle-dispatch"><span class="std std-ref">調度表</span></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.3 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Pickler.reducer_override">
<span class="sig-name descname"><span class="pre">reducer_override</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Pickler.reducer_override" title="連結到這個定義">¶</a></dt>
<dd><p>一個可以在 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 子類別中被定義的縮減器（reducer）。這個方法的優先度高於任何其他 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">分派表</span></code></a> 中的縮減器。他應該要有和 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 方法相同的函數界面，且可以可選地回傳 <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> 以退回（fallback）使用 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">分派表</span></code></a> 中登錄的縮減方法來封裝 <code class="docutils literal notranslate"><span class="pre">obj</span></code>。</p>
<p>請查閱 <a class="reference internal" href="#reducer-override"><span class="std std-ref">針對型別、函數或特定物件定製縮減函數</span></a> 來參考其他較詳細的範例。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="pickle.Pickler.fast">
<span class="sig-name descname"><span class="pre">fast</span></span><a class="headerlink" href="#pickle.Pickler.fast" title="連結到這個定義">¶</a></dt>
<dd><p>已棄用。如果設置為 true，將啟用快速模式。快速模式會停用備忘（memo），因此能透過不產生多餘的 PUT 操作碼（OpCode）來加速封裝過程。它不應被用於自我參照物件，否則將導致 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 陷入無限遞迴。</p>
<p>使用 <a class="reference internal" href="pickletools.html#pickletools.optimize" title="pickletools.optimize"><code class="xref py py-func docutils literal notranslate"><span class="pre">pickletools.optimize()</span></code></a> 以獲得更緊湊的 pickle 輸出。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pickle.Unpickler">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">Unpickler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fix_imports</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">encoding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'ASCII'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">errors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'strict'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">buffers</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler" title="連結到這個定義">¶</a></dt>
<dd><p>這個物件接受一個二進位檔案 <em>file</em> 來從中讀取 pickle 資料流。</p>
<p>協定版本號會被自動偵測，所以不需要在這邊手動輸入。</p>
<p>參數 <em>file</em> 必須擁有三個方法，分別是接受整數作為引數的 read() 方法、接受緩衝區作為引數的 readinto() 方法以及不需要引數的 readline() 方法，如同在 <a class="reference internal" href="io.html#io.BufferedIOBase" title="io.BufferedIOBase"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BufferedIOBase</span></code></a> 的介面一樣。因此，<em>file</em> 可以是一個以二進位讀取模式開啟的檔案、一個 <a class="reference internal" href="io.html#io.BytesIO" title="io.BytesIO"><code class="xref py py-class docutils literal notranslate"><span class="pre">io.BytesIO</span></code></a> 物件、或任何符合此介面的自訂物件。</p>
<p>可選引數 <em>fix_imports</em>、<em>encoding</em> 和 <em>errors</em> 用來控制 Python 2 pickle 資料的相容性支援。如果 <em>fix_imports</em> 為 true，則 pickle 模組會嘗試將舊的 Python 2 模組名稱映射到 Python 3 中使用的新名稱。<em>encoding</em> 和 <em>errors</em> 告訴 pickle 模組如何解碼由 Python 2 pickle 封裝的 8 位元字串實例；<em>encoding</em> 和 <em>errors</em> 預設分別為 'ASCII' 和 'strict'。<em>encoding</em> 可以設定為 'bytes' 以將這些 8 位元字串實例讀為位元組物件。而由 Python 2 封裝的 NumPy 陣列、<a class="reference internal" href="datetime.html#datetime.datetime" title="datetime.datetime"><code class="xref py py-class docutils literal notranslate"><span class="pre">datetime</span></code></a>、<a class="reference internal" href="datetime.html#datetime.date" title="datetime.date"><code class="xref py py-class docutils literal notranslate"><span class="pre">date</span></code></a> 和 <a class="reference internal" href="datetime.html#datetime.time" title="datetime.time"><code class="xref py py-class docutils literal notranslate"><span class="pre">time</span></code></a> 的實例則必須使用 <code class="docutils literal notranslate"><span class="pre">encoding='latin1'</span></code> 來拆封。</p>
<p>如果 <em>buffers</em> 是 <code class="docutils literal notranslate"><span class="pre">None</span></code>（預設值），那麼去序列化所需的所有資料都必須已經包含在 pickle 串流中。這意味著當初在建立對應的 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 時（或在呼叫 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> 或 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 時）*buffer_callback* 引數必須為 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p>
<p>如果 <em>buffers</em> 不是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，則其應該是一個可疊代物件，內含數個支援緩衝區的物件，並且每當 pickle 串流引用一個<a class="reference internal" href="#pickle-oob"><span class="std std-ref">帶外</span></a>緩衝區視圖時將會被照順序消耗。這些緩衝資料當初建立時應已按照順序給定予 Pickler 物件中的 <em>buffer_callback</em>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.8 版的變更: </span>新增 <em>buffer</em> 引數。</p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pickle.Unpickler.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler.load" title="連結到這個定義">¶</a></dt>
<dd><p>開啟先前被傳入建構子的檔案，從中讀取一個被 pickle 封裝的物件，並回傳重建完成的物件階層。超過 pickle 表示範圍的位元組會被忽略。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Unpickler.persistent_load">
<span class="sig-name descname"><span class="pre">persistent_load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pid</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler.persistent_load" title="連結到這個定義">¶</a></dt>
<dd><p>預設會拋出 <a class="reference internal" href="#pickle.UnpicklingError" title="pickle.UnpicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a> 例外。</p>
<p>若有定義 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a>，則其將回傳符合持久化識別碼 <cite>pid</cite> 的物件。如果遭遇了無效的持久化識別碼，則會引發 <a class="reference internal" href="#pickle.UnpicklingError" title="pickle.UnpicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a>。</p>
<p>關於細節與用法範例請見 <a class="reference internal" href="#pickle-persistent"><span class="std std-ref">外部物件持久化</span></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.13 版的變更: </span>Add the default implementation of this method in the C implementation
of <code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code>.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.Unpickler.find_class">
<span class="sig-name descname"><span class="pre">find_class</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">module</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">name</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.Unpickler.find_class" title="連結到這個定義">¶</a></dt>
<dd><p>如有需要將引入 <em>module</em> ，並從中返回名為 <em>name</em> 的物件，這裡的 <em>module</em> 和 <em>name</em> 引數接受的輸入是 <a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> 物件。注意，雖然名稱上看起來不像，但 <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">find_class()</span></code></a> 亦可被用於尋找其他函式。</p>
<p>子類別可以覆寫此方法以控制可以載入哪些類型的物件、以及如何載入它們，從而潛在地降低安全性風險。詳情請參考<a class="reference internal" href="#pickle-restrict"><span class="std std-ref">限制全域物件</span></a>。</p>
<p class="audit-hook">引發一個附帶引數 <code class="docutils literal notranslate"><span class="pre">module</span></code>、<code class="docutils literal notranslate"><span class="pre">name</span></code> 的<a class="reference internal" href="sys.html#auditing"><span class="std std-ref">稽核事件</span></a> <code class="docutils literal notranslate"><span class="pre">pickle.find_class</span></code>。</p>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="pickle.PickleBuffer">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">pickle.</span></span><span class="sig-name descname"><span class="pre">PickleBuffer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">buffer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#pickle.PickleBuffer" title="連結到這個定義">¶</a></dt>
<dd><p>一個表示了含有可封裝數據緩衝區的包裝函數（wrapper function）。<em>buffer</em> 必須是一個 <a class="reference internal" href="../c-api/buffer.html#bufferobjects"><span class="std std-ref">提供緩衝區</span></a> 的物件，例如一個 <a class="reference internal" href="../glossary.html#term-bytes-like-object"><span class="xref std std-term">類位元組物件</span></a> 或 N 維陣列。</p>
<p><a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 本身就是一個提供緩衝區的物件，所以是能夠將其提供給其它「預期收到含有緩衝物件的 API」的，比如 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。</p>
<p><a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 物件僅能由 5 版或以上的 pickle 協定進行封裝。該物件亦能被作為帶外資料來進行<a class="reference internal" href="#pickle-oob"><span class="std std-ref">帶外資料序列化</span></a></p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="pickle.PickleBuffer.raw">
<span class="sig-name descname"><span class="pre">raw</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pickle.PickleBuffer.raw" title="連結到這個定義">¶</a></dt>
<dd><p>返回此緩衝區底層記憶體區域的 <a class="reference internal" href="stdtypes.html#memoryview" title="memoryview"><code class="xref py py-class docutils literal notranslate"><span class="pre">memoryview</span></code></a>。被返回的物件是一個（在 C 語言的 formatter 格式中）以 <code class="docutils literal notranslate"><span class="pre">B</span></code> (unsigned bytes) 二進位格式儲存、一維且列連續（C-contiguous）的 memoryview。如果緩衝區既不是列連續（C-contiguous）也不是行連續（Fortran-contiguous）的，則會引發 <a class="reference internal" href="exceptions.html#BufferError" title="BufferError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">BufferError</span></code></a>。</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="pickle.PickleBuffer.release">
<span class="sig-name descname"><span class="pre">release</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#pickle.PickleBuffer.release" title="連結到這個定義">¶</a></dt>
<dd><p>釋放 PickleBuffer 物件現正曝光中的緩衝區。</p>
</dd></dl>

</dd></dl>

</section>
<section id="what-can-be-pickled-and-unpickled">
<span id="pickle-picklable"></span><h2>哪些物件能或不能被封裝、拆封？<a class="headerlink" href="#what-can-be-pickled-and-unpickled" title="連結到這個標頭">¶</a></h2>
<p>下列型別可以被封裝：</p>
<ul class="simple">
<li><p>內建常數（<code class="docutils literal notranslate"><span class="pre">None</span></code>、<code class="docutils literal notranslate"><span class="pre">True</span></code>、<code class="docutils literal notranslate"><span class="pre">False</span></code>、<code class="docutils literal notranslate"><span class="pre">Ellipsis</span></code> 和 <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a>）；</p></li>
<li><p>整數、浮點數和複數；</p></li>
<li><p>字串、位元組物件、位元組陣列；</p></li>
<li><p>元組（tuple）、串列（list）、集合（set）和僅含有可封裝物件的字典；</p></li>
<li><p>在模組最表面的層級就能被存取的函式（內建或自訂的皆可，不過僅限使用 <a class="reference internal" href="../reference/compound_stmts.html#def"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">def</span></code></a> 定義的函式，<a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 函式不適用）；</p></li>
<li><p>在模組最表面的層級就能被存取的類別；</p></li>
<li><p>實例，只要在呼叫了 <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 後其回傳值全都是可封裝物件。（詳情請參閱 <a class="reference internal" href="#pickle-inst"><span class="std std-ref">Pickling 類別實例</span></a>）。</p></li>
</ul>
<p>嘗試封裝無法封裝的物件會引發 <a class="reference internal" href="#pickle.PicklingError" title="pickle.PicklingError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">PicklingError</span></code></a> 例外；注意當這種情況發生時，可能已經有未知數量的位元組已被寫入到檔案。嘗試封裝深度遞迴的資料結構可能會導致其超出最大遞迴深度，在這種情況下會引發 <a class="reference internal" href="exceptions.html#RecursionError" title="RecursionError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">RecursionError</span></code></a> 例外。你可以（小心地）使用 <a class="reference internal" href="sys.html#sys.setrecursionlimit" title="sys.setrecursionlimit"><code class="xref py py-func docutils literal notranslate"><span class="pre">sys.setrecursionlimit()</span></code></a> 來提高此上限。</p>
<p>請注意，函式（內建及自訂兩者皆是）是依據完整的 <a class="reference internal" href="../glossary.html#term-qualified-name"><span class="xref std std-term">限定名稱</span></a> 來封裝，而非依其值。<a class="footnote-reference brackets" href="#id8" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>2<span class="fn-bracket">]</span></a> 這意味著封裝時只有函式名稱、所屬的模組和所屬的類別名稱會被封裝。函式本身的程式碼及其附帶的任何屬性均不會被封裝。因此，在拆封該物件的環境中，定義此函式的模組必須可被引入，且該模組必須包含具此命名之物件，否則將引發例外。 <a class="footnote-reference brackets" href="#id9" id="id4" role="doc-noteref"><span class="fn-bracket">[</span>3<span class="fn-bracket">]</span></a></p>
<p>同樣情況，類別是依照其完整限定名稱來進行封裝，因此在進行拆封的環境中會具有同上的限制。類別中的程式碼或資料皆不會被封裝，因此在以下範例中，注意到類別屬性 <code class="docutils literal notranslate"><span class="pre">attr</span></code> 在拆封的環境中不會被還原:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">:</span>
    <span class="n">attr</span> <span class="o">=</span> <span class="s1">&#39;A class attribute&#39;</span>

<span class="n">picklestring</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">Foo</span><span class="p">)</span>
</pre></div>
</div>
<p>這些限制就是可封裝的函式和類別必須被定義在模組頂層的原因。</p>
<p>同樣地，當類別實例被封裝時，它所屬類別具有的程式碼和資料不會被一起封裝。只有實例資料本身會被封裝。這是有意而為的，因為如此你才可以在類別中修正錯誤或新增其他方法，且於此同時仍能夠載入使用較早期版本的類別所建立的物件實例。如果您預計將有長期存在的物件、且該物件將經歷許多版本的更替，你可以在物件中存放一個版本號，以便未來能透過 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 方法來進行適當的版本轉換。</p>
</section>
<section id="pickling-class-instances">
<span id="pickle-inst"></span><h2>Pickling 類別實例<a class="headerlink" href="#pickling-class-instances" title="連結到這個標頭">¶</a></h2>
<p>在這一個章節，我們會講述如何封裝或拆封一個物件實例的相關機制，以方便你進行自訂。</p>
<p>大部分的實例不需要額外的程式碼就已經是可封裝的了。在這樣的預設狀況中，pickle 模組透過自省機制來取得類別及其實例的屬性。當類別實例被拆封時，其 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a> 方法通常*不會*被呼叫。預設行為首先會建立一個未初始化的實例，然後還原紀錄中的屬性。以下程式碼的實作展示了前述行為:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">restore</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">attributes</span><span class="p">):</span>
    <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">obj</span>
</pre></div>
</div>
<p>被封裝的目標類別可以提供一個或數個下列特殊方法來改變 pickle 的預設行為：</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__getnewargs_ex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getnewargs_ex__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__getnewargs_ex__" title="連結到這個定義">¶</a></dt>
<dd><p>在第 2 版協定或更新的版本中，有實作 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 方法的類別，可以決定在拆封時要傳遞給 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 方法的值。該方法必須回傳一個 <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">kwargs)</span></code> 的組合，其中 <em>args</em> 是一個位置引數的元組（tuple），<em>kwargs</em> 是一個用於建構物件的命名引數字典。這些資訊將在拆封時傳遞給 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 方法。</p>
<p>如果目標類別的方法 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 需要僅限關鍵字的參數時，你應該實作此方法。否則，為了提高相容性，建議你改為實作 <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版的變更: </span>在第 2、3 版的協定中現在改為使用 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getnewargs__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getnewargs__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__getnewargs__" title="連結到這個定義">¶</a></dt>
<dd><p>此方法與 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 的目的一樣，但僅支援位置參數。它必須回傳一個由傳入引數所組成的元組（tuple）<code class="docutils literal notranslate"><span class="pre">args</span></code>，這些引數會在拆封時傳遞給 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 方法。</p>
<p>當有定義 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a> 的時候便不會呼叫 <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a>。</p>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.6 版的變更: </span>在 Python 3.6 之前、版本 2 和版本 3 的協定中，會呼叫 <a class="reference internal" href="#object.__getnewargs__" title="object.__getnewargs__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a> 而非 <a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a>。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__getstate__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__getstate__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__getstate__" title="連結到這個定義">¶</a></dt>
<dd><p>目標類別可以透過覆寫方法 <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 進一步影響其實例被封裝的方式。封裝時，呼叫該方法所返回的物件將作為該實例的內容被封裝、而非一個預設狀態。以下列出幾種預設狀態：</p>
<ul class="simple">
<li><p>沒有 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 實例的類別，其預設狀態為 <code class="docutils literal notranslate"><span class="pre">None</span></code>。</p></li>
<li><p>有 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 實例、但沒有 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 實例的類別，其預設狀態為 <code class="docutils literal notranslate"><span class="pre">self.__dict__</span></code>。</p></li>
<li><p>有 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 和 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 實例的類別，其預設狀態是一個含有兩個字典的元組（tuple），該二字典分別為 <code class="docutils literal notranslate"><span class="pre">self.__dict__</span></code> 本身，和紀錄欄位（slot）名稱和值對應關係的字典（只有含有值的欄位（slot）會被紀錄其中）。</p></li>
<li><p>沒有 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 但有 <a class="reference internal" href="../reference/datamodel.html#object.__slots__" title="object.__slots__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__slots__</span></code></a> 實例的類別，其預設狀態是一個二元組（tuple），元組中的第一個值是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，第二個值則是紀錄欄位（slot）名稱和值對應關係的字典（與前一項提到的字典是同一個）。</p></li>
</ul>
<div class="versionchanged">
<p><span class="versionmodified changed">在 3.11 版的變更: </span>在 <a class="reference internal" href="functions.html#object" title="object"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a> 類別中增加預設的 <code class="docutils literal notranslate"><span class="pre">__getstate__()</span></code> 實作。</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__setstate__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__setstate__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__setstate__" title="連結到這個定義">¶</a></dt>
<dd><p>在拆封時，如果類別定義了 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>，則會使用拆封後的狀態呼叫它。在這種情況下，紀錄狀態的物件不需要是字典（dictionary）。否則，封裝時的狀態紀錄必須是一個字典，其紀錄的項目將被賦值給新實例的字典。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>如果 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 在封裝時返回了 <code class="docutils literal notranslate"><span class="pre">None</span></code> 狀態，則拆封時就不會去呼叫 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>。</p>
</div>
</dd></dl>

<p>參閱 <a class="reference internal" href="#pickle-state"><span class="std std-ref">處裡紀錄大量狀態的物件</span></a> 以了解 <a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 和 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 的使用方法。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>在拆封時，某些方法如 <a class="reference internal" href="../reference/datamodel.html#object.__getattr__" title="object.__getattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattr__()</span></code></a>、<a class="reference internal" href="../reference/datamodel.html#object.__getattribute__" title="object.__getattribute__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getattribute__()</span></code></a> 或 <a class="reference internal" href="../reference/datamodel.html#object.__setattr__" title="object.__setattr__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setattr__()</span></code></a> 可能會在建立實例時被呼叫。如果這些方法依賴了某些實例內部的不變性，則應實作 <a class="reference internal" href="../reference/datamodel.html#object.__new__" title="object.__new__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code></a> 以建立此不變性，因為在拆封實例時不會呼叫 <a class="reference internal" href="../reference/datamodel.html#object.__init__" title="object.__init__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code></a>。</p>
</div>
<p id="index-5">如稍後所演示，pickle 並不直接使用上述方法。這些方法實際上是實作了 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 特殊方法的拷貝協定（copy protocol）。拷貝協定提供了統一的介面，以檢索進行封裝及複製物件時所需的資料。 <a class="footnote-reference brackets" href="#id10" id="id5" role="doc-noteref"><span class="fn-bracket">[</span>4<span class="fn-bracket">]</span></a></p>
<p>直接在類別中實作 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 雖然功能強大但卻容易導致出錯。因此，設計類別者應盡可能使用高階介面（例如，<a class="reference internal" href="#object.__getnewargs_ex__" title="object.__getnewargs_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a>、<a class="reference internal" href="#object.__getstate__" title="object.__getstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code></a> 和 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>）。不過，我們也將展示一些特例狀況，在這些狀況中，使用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code> 可能是唯一的選擇、是更有效率的封裝方法或二者兼備。</p>
<dl class="py method">
<dt class="sig sig-object py" id="object.__reduce__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reduce__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#object.__reduce__" title="連結到這個定義">¶</a></dt>
<dd><p>目前的介面定義如下。 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 方法不接受引數，且應回傳一個字串或一個元組（元組一般而言是較佳的選擇；所回傳的物件通常稱為「縮減值」）。</p>
<p>如果回傳的是字串，該字串應被解讀為一個全域變數的名稱。它應是該物件相對其所在模組的本地名稱；pickle 模組會在模組命名空間中尋找，以確定該物件所在的模組。這種行為通常對於單例物件特別有用。</p>
<p>當返回一個元組時，其長度必須介於兩至六項元素之間。可選項可以被省略，或者其值可以被設為 <code class="docutils literal notranslate"><span class="pre">None</span></code>。各項物件的語意依序為：</p>
<ul>
<li><p>一個將會被呼叫來創建初始版本物件的可呼叫物件。</p></li>
<li><p>一個用於傳遞引數給前述物件的元組。如果前述物件不接受引數輸入，則你仍應在這裡給定一個空元組。</p></li>
<li><p>可選項。物件狀態。如前所述，會被傳遞給該物件的 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 方法。如果該物件沒有實作此方法，則本值必須是一個字典，且其將會被新增到物件的 <a class="reference internal" href="../reference/datamodel.html#object.__dict__" title="object.__dict__"><code class="xref py py-attr docutils literal notranslate"><span class="pre">__dict__</span></code></a> 屬性中。</p></li>
<li><p>可選項。一個用來提供連續項目的疊代器（而非序列）。這些項目將個別透過 <code class="docutils literal notranslate"><span class="pre">obj.append(item)</span></code> 方法或成批次地透過 <code class="docutils literal notranslate"><span class="pre">obj.extend(list_of_items)</span></code> 方法被附加到物件中。主要用於串列（list）子類別，但只要其他類別具有相應的 <a class="reference internal" href="stdtypes.html#typesseq-common"><span class="std std-ref">append 和 extend 方法</span></a>以及相同的函式簽章（signature）就也可以使用。 （是否會調用 <code class="xref py py-meth docutils literal notranslate"><span class="pre">append()</span></code> 或 <code class="xref py py-meth docutils literal notranslate"><span class="pre">extend()</span></code> 方法將取決於所選用的 pickle 協定版本以及要附加的項目數量，因此必須同時支援這兩種方法。）</p></li>
<li><p>可選項。一個產生連續鍵值對的疊代器（不是序列）。這些項目將以 <code class="docutils literal notranslate"><span class="pre">obj[key]</span> <span class="pre">=</span> <span class="pre">value</span></code> 方式被儲存到物件中。主要用於字典（dictionary）子類別，但只要有實現了 <a class="reference internal" href="../reference/datamodel.html#object.__setitem__" title="object.__setitem__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setitem__()</span></code></a> 的其他類別也可以使用。</p></li>
<li><p>可選項。一個具有 <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code> 函式簽章（signature）的可呼叫物件。該物件允許使用者以可編寫的邏輯，而不是物件 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 預設的 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a> 靜態方法去控制特定物件的狀態更新方式。如果這個物件不是 <code class="docutils literal notranslate"><span class="pre">None</span></code>，這個物件的呼叫優先權將優於物件 <code class="docutils literal notranslate"><span class="pre">obj</span></code> 的 <a class="reference internal" href="#object.__setstate__" title="object.__setstate__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code></a>。</p>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入: </span>加入第六個可選項（一個 <code class="docutils literal notranslate"><span class="pre">(obj,</span> <span class="pre">state)</span></code> 元組）。</p>
</div>
</li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="object.__reduce_ex__">
<span class="sig-prename descclassname"><span class="pre">object.</span></span><span class="sig-name descname"><span class="pre">__reduce_ex__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">protocol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#object.__reduce_ex__" title="連結到這個定義">¶</a></dt>
<dd><p>另外，你也可以定義一個 <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a> 方法。唯一的不同的地方是此方法只接受協定版本（整數）作為參數。當有定義本方法時，pickle 會優先調用它而不是 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 。此外，呼叫 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a> 時也會自動變成呼叫這個變體版本。此方法主要是為了向後相容的舊的 Python 版本而存在。</p>
</dd></dl>

<section id="persistence-of-external-objects">
<span id="pickle-persistent"></span><h3>外部物件持久化<a class="headerlink" href="#persistence-of-external-objects" title="連結到這個標頭">¶</a></h3>
<p id="index-6">為了方便物件持久化，<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組支援對被封裝資料串流以外的物件參照。被參照的物件是透過一個持久化 ID 來參照的，這個 ID 應該要是字母數字字元（alphanumeric）組成的字串（協定 0） <a class="footnote-reference brackets" href="#id11" id="id6" role="doc-noteref"><span class="fn-bracket">[</span>5<span class="fn-bracket">]</span></a> 或者是任意的物件（任何較新的協定）。</p>
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 沒有定義要如何解決或分派這個持久化 ID 的問題；故其處理方式有賴使用者自行定義在封裝器（pickler）以及拆封器（unpickler）中。方法的名稱各自為 <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a> 和 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a>。</p>
<p>要封裝具有外部持久化 ID 的物件，封裝器（pickler）必須擁有一個自訂的方法 <a class="reference internal" href="#pickle.Pickler.persistent_id" title="pickle.Pickler.persistent_id"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_id()</span></code></a>，這個方法將接收一個物件作為參數，並回傳 <cite>None</cite> 或該物件的持久化 ID。當回傳 <cite>None</cite> 時，封裝器會正常地封裝該物件。當回傳一個持久化 ID 字串時，封裝器會封裝該物件並加上一個標記，讓拆封器（unpikler）能識別它是一個持久化 ID。</p>
<p>要拆封外部物件，拆封器（unpickler）必須有一個自訂的 <a class="reference internal" href="#pickle.Unpickler.persistent_load" title="pickle.Unpickler.persistent_load"><code class="xref py py-meth docutils literal notranslate"><span class="pre">persistent_load()</span></code></a> 方法，該方法應接受一個持久化 ID 物件，並回傳相對應的物件。</p>
<p>以下是一個完整的範例，用以說明如何使用持久化 ID 來封裝具外部參照的物件。</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 展示如何使用持久化 ID 來封裝外部物件的簡單範例</span>

<span class="kn">import</span> <span class="nn">pickle</span>
<span class="kn">import</span> <span class="nn">sqlite3</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">namedtuple</span>

<span class="c1"># 代表資料庫中紀錄的一個簡易類別</span>
<span class="n">MemoRecord</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="s2">&quot;key, task&quot;</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DBPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">persistent_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="c1"># 我們派發出一個持久 ID，而不是像一般類別實例那樣封裝 MemoRecord。</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">MemoRecord</span><span class="p">):</span>
            <span class="c1"># 我們的持久 ID 就是一個元組，裡面包含一個標籤和一個鍵，指向資料庫中的特定紀錄。</span>
            <span class="k">return</span> <span class="p">(</span><span class="s2">&quot;MemoRecord&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 如果 obj 沒有持久 ID，則返回 None。這表示 obj 像平常那樣封裝即可。</span>
            <span class="k">return</span> <span class="kc">None</span>


<span class="k">class</span> <span class="nc">DBUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">connection</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connection</span> <span class="o">=</span> <span class="n">connection</span>

    <span class="k">def</span> <span class="nf">persistent_load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pid</span><span class="p">):</span>
        <span class="c1"># 每當遇到持久 ID 時，此方法都會被呼叫。</span>
        <span class="c1"># pid 是 DBPickler 所回傳的元組。</span>
        <span class="n">cursor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
        <span class="n">type_tag</span><span class="p">,</span> <span class="n">key_id</span> <span class="o">=</span> <span class="n">pid</span>
        <span class="k">if</span> <span class="n">type_tag</span> <span class="o">==</span> <span class="s2">&quot;MemoRecord&quot;</span><span class="p">:</span>
            <span class="c1"># 從資料庫中抓取所引用的紀錄並返回。</span>
            <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM memos WHERE key=?&quot;</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key_id</span><span class="p">),))</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="o">=</span> <span class="n">cursor</span><span class="o">.</span><span class="n">fetchone</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 如果無法返回正確的物件，則必須拋出錯誤。</span>
            <span class="c1"># 否則 unpickler 會誤認為 None 是持久 ID 所引用的物件。</span>
            <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">&quot;unsupported persistent object&quot;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="kn">import</span> <span class="nn">io</span>
    <span class="kn">import</span> <span class="nn">pprint</span>

    <span class="c1"># 初始化資料庫。</span>
    <span class="n">conn</span> <span class="o">=</span> <span class="n">sqlite3</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s2">&quot;:memory:&quot;</span><span class="p">)</span>
    <span class="n">cursor</span> <span class="o">=</span> <span class="n">conn</span><span class="o">.</span><span class="n">cursor</span><span class="p">()</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;CREATE TABLE memos(key INTEGER PRIMARY KEY, task TEXT)&quot;</span><span class="p">)</span>
    <span class="n">tasks</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;give food to fish&#39;</span><span class="p">,</span>
        <span class="s1">&#39;prepare group meeting&#39;</span><span class="p">,</span>
        <span class="s1">&#39;fight with a zebra&#39;</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">tasks</span><span class="p">:</span>
        <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;INSERT INTO memos VALUES(NULL, ?)&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">task</span><span class="p">,))</span>

    <span class="c1"># 抓取要封裝的紀錄。</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;SELECT * FROM memos&quot;</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="p">[</span><span class="n">MemoRecord</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">task</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">task</span> <span class="ow">in</span> <span class="n">cursor</span><span class="p">]</span>
    <span class="c1"># 使用我們自訂的 DBPickler 來保存紀錄。</span>
    <span class="n">file</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
    <span class="n">DBPickler</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;被封裝的紀錄:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>

    <span class="c1"># 更新一筆紀錄（測試用）。</span>
    <span class="n">cursor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="s2">&quot;UPDATE memos SET task=&#39;learn italian&#39; WHERE key=1&quot;</span><span class="p">)</span>

    <span class="c1"># 從 pickle 資料流中載入紀錄。</span>
    <span class="n">file</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">memos</span> <span class="o">=</span> <span class="n">DBUnpickler</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;已拆封的紀錄:&quot;</span><span class="p">)</span>
    <span class="n">pprint</span><span class="o">.</span><span class="n">pprint</span><span class="p">(</span><span class="n">memos</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="dispatch-tables">
<span id="pickle-dispatch"></span><h3>調度表<a class="headerlink" href="#dispatch-tables" title="連結到這個標頭">¶</a></h3>
<p>如果你希望在不干擾其他物件正常封裝的前提下建立一個針對特定物件的封裝器，你可建立一個有私密調度表的封裝器。</p>
<p>由 <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 模組管理的全域調度表可以 <code class="xref py py-data docutils literal notranslate"><span class="pre">copyreg.dispatch_table</span></code> 呼叫。你可以透過這個方式來基於原始 <code class="xref py py-data docutils literal notranslate"><span class="pre">copyreg.dispatch_table</span></code> 創建一個修改過的版本，作為你的專屬用途的調度表。</p>
<p>舉例來說：</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">dispatch_table</span> <span class="o">=</span> <span class="n">copyreg</span><span class="o">.</span><span class="n">dispatch_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">p</span><span class="o">.</span><span class="n">dispatch_table</span><span class="p">[</span><span class="n">SomeClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_SomeClass</span>
</pre></div>
</div>
<p>建立了一個 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">pickle.Pickler</span></code></a>，其中含有專門處裡 <code class="docutils literal notranslate"><span class="pre">SomeClass</span></code> 類別的專屬調度表。此外，你也可以寫作：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MyPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>
    <span class="n">dispatch_table</span> <span class="o">=</span> <span class="n">copyreg</span><span class="o">.</span><span class="n">dispatch_table</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">dispatch_table</span><span class="p">[</span><span class="n">SomeClass</span><span class="p">]</span> <span class="o">=</span> <span class="n">reduce_SomeClass</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">MyPickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>這樣可產生相似的結果，唯一不同的是往後所有 <code class="docutils literal notranslate"><span class="pre">MyPickler</span></code> 預設都會使用這個專屬調度表。最後，如果將程式寫為：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">copyreg</span><span class="o">.</span><span class="n">pickle</span><span class="p">(</span><span class="n">SomeClass</span><span class="p">,</span> <span class="n">reduce_SomeClass</span><span class="p">)</span>
<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<p>則會改變 <a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 模組內建、所有使用者共通的調度表。</p>
</section>
<section id="handling-stateful-objects">
<span id="pickle-state"></span><h3>處裡紀錄大量狀態的物件<a class="headerlink" href="#handling-stateful-objects" title="連結到這個標頭">¶</a></h3>
<p id="index-7">以下的範例展示了如何修改針對特定類別封裝時的行為。下面的 <code class="xref py py-class docutils literal notranslate"><span class="pre">TextReader</span></code> 類別會開啟一個文字檔案，並在每次呼叫其 <code class="xref py py-meth docutils literal notranslate"><span class="pre">readline()</span></code> 方法時返回當前行編號與該行內容。如果 <code class="xref py py-class docutils literal notranslate"><span class="pre">TextReader</span></code> 實例被封裝，所有*除了檔案物件之外*的屬性成員都會被保存。在該實例被拆封時，檔案將被重新開啟，並從上次的位置繼續讀取。這個行為的達成是透過 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__setstate__()</span></code> 和 <code class="xref py py-meth docutils literal notranslate"><span class="pre">__getstate__()</span></code> 方法來實作的。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">TextReader</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;列出文字檔案中的行並對其進行編號。&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">filename</span> <span class="o">=</span> <span class="n">filename</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lineno</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">%i</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># 從 self.__dict__ 中複製物件的狀態。包含了所有的實例屬性。</span>
        <span class="c1"># 使用 dict.copy() 方法以避免修改原始狀態。</span>
        <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># 移除不可封裝的項目。</span>
        <span class="k">del</span> <span class="n">state</span><span class="p">[</span><span class="s1">&#39;file&#39;</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="c1"># 恢復實例屬性（即 filename 和 lineno）。</span>
        <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="c1"># 恢復到先前開啟了檔案的狀態。為此，我們需要重新開啟它並一直讀取到行數編號相同。</span>
        <span class="n">file</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lineno</span><span class="p">):</span>
            <span class="n">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="c1"># 存檔。</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">file</span> <span class="o">=</span> <span class="n">file</span>
</pre></div>
</div>
<p>可以這樣實際使用：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span> <span class="o">=</span> <span class="n">TextReader</span><span class="p">(</span><span class="s2">&quot;hello.txt&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;1: Hello world!&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;2: I am line number two.&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">reader</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">new_reader</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="go">&#39;3: Goodbye!&#39;</span>
</pre></div>
</div>
</section>
</section>
<section id="custom-reduction-for-types-functions-and-other-objects">
<span id="reducer-override"></span><h2>針對型別、函數或特定物件定製縮減函數<a class="headerlink" href="#custom-reduction-for-types-functions-and-other-objects" title="連結到這個標頭">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<p>有時候，<a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 的彈性空間可能不夠。尤其當我們想要使用型別以外的方式來判斷如何使用自訂封裝、或者我們想要自訂特定函式和類別的封裝方法時。</p>
<p>如果是這樣的話，可以繼承 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a> 類別並實作一個 <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> 方法。此方法可以回傳任意的縮減元組（參閱 <a class="reference internal" href="#object.__reduce__" title="object.__reduce__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce__()</span></code></a>）、也可以回傳 <a class="reference internal" href="constants.html#NotImplemented" title="NotImplemented"><code class="xref py py-data docutils literal notranslate"><span class="pre">NotImplemented</span></code></a> 以回退至原始的行為。</p>
<p>如果 <a class="reference internal" href="#pickle.Pickler.dispatch_table" title="pickle.Pickler.dispatch_table"><code class="xref py py-attr docutils literal notranslate"><span class="pre">dispatch_table</span></code></a> 和 <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> 都被定義了的話，<a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a> 的優先度較高。</p>
<div class="admonition note">
<p class="admonition-title">備註</p>
<p>出於效能考量，處裡以下物件可能不會呼叫 <a class="reference internal" href="#pickle.Pickler.reducer_override" title="pickle.Pickler.reducer_override"><code class="xref py py-meth docutils literal notranslate"><span class="pre">reducer_override()</span></code></a>：<code class="docutils literal notranslate"><span class="pre">None</span></code>、<code class="docutils literal notranslate"><span class="pre">True</span></code>、<code class="docutils literal notranslate"><span class="pre">False</span></code>，以及 <a class="reference internal" href="functions.html#int" title="int"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>、<a class="reference internal" href="functions.html#float" title="float"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>、<a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a>、<a class="reference internal" href="stdtypes.html#str" title="str"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>、<a class="reference internal" href="stdtypes.html#dict" title="dict"><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></a>、<a class="reference internal" href="stdtypes.html#set" title="set"><code class="xref py py-class docutils literal notranslate"><span class="pre">set</span></code></a>、<a class="reference internal" href="stdtypes.html#frozenset" title="frozenset"><code class="xref py py-class docutils literal notranslate"><span class="pre">frozenset</span></code></a>、<a class="reference internal" href="stdtypes.html#list" title="list"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> 和 <a class="reference internal" href="stdtypes.html#tuple" title="tuple"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a> 的實例。</p>
</div>
<p>以下是一個簡單的例子，我們示範如何允許封裝和重建給定的類別：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">class</span> <span class="nc">MyClass</span><span class="p">:</span>
    <span class="n">my_attribute</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">class</span> <span class="nc">MyPickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Pickler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">reducer_override</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;MyClass 的自訂縮減函數。&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;__name__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;MyClass&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span>
                          <span class="p">{</span><span class="s1">&#39;my_attribute&#39;</span><span class="p">:</span> <span class="n">obj</span><span class="o">.</span><span class="n">my_attribute</span><span class="p">})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># 遭遇其他物件，則使用一般的縮減方式</span>
            <span class="k">return</span> <span class="bp">NotImplemented</span>

<span class="n">f</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">()</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">MyPickler</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
<span class="n">p</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">MyClass</span><span class="p">)</span>

<span class="k">del</span> <span class="n">MyClass</span>

<span class="n">unpickled_class</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">getvalue</span><span class="p">())</span>

<span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">unpickled_class</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">unpickled_class</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;MyClass&quot;</span>
<span class="k">assert</span> <span class="n">unpickled_class</span><span class="o">.</span><span class="n">my_attribute</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
</section>
<section id="out-of-band-buffers">
<span id="pickle-oob"></span><h2>帶外（Out-of-band）資料緩衝區<a class="headerlink" href="#out-of-band-buffers" title="連結到這個標頭">¶</a></h2>
<div class="versionadded">
<p><span class="versionmodified added">在 3.8 版被加入.</span></p>
</div>
<p><a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組會被用於用於傳輸龐大的資料。此時，將複製記憶體的次數降到最低以保持效能變得很重要。然而，<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組的正常操作過程中，當它將物件的圖狀結構（graph-like structure）轉換為連續的位元組串流時，本質上就涉及將資料複製到封裝流以及從封裝流複製資料。</p>
<p>如果*供給者*（被傳遞物件的型別的實作）與*消費者*（資訊交換系統的實作）都支援由 pickle 協定 5 或更高版本提供的帶外傳輸功能，則可以避免此一先天限制。</p>
<section id="provider-api">
<h3>供給者 API<a class="headerlink" href="#provider-api" title="連結到這個標頭">¶</a></h3>
<p>要封裝的大型資料物件，則必須實作一個針對 5 版協定及以上的 <a class="reference internal" href="#object.__reduce_ex__" title="object.__reduce_ex__"><code class="xref py py-meth docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a> 方法，該方法應返回一個 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 實例來處理任何大型資料（而非返回如 <a class="reference internal" href="stdtypes.html#bytes" title="bytes"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytes</span></code></a> 物件）。</p>
<p>一個 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 物件*指示*了當下底層的緩衝區狀態適合進行帶外資料傳輸。這些物件仍然相容 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組的一般使用方式。消費者程式也可以選擇介入，指示 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 他們將自行處理這些緩衝區。</p>
</section>
<section id="consumer-api">
<h3>消費者 API<a class="headerlink" href="#consumer-api" title="連結到這個標頭">¶</a></h3>
<p>一個資訊交換系統可以決定要自行處裡序列化物件圖時產生的 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 物件。</p>
<p>傳送端需要傳遞一個調用緩衝區的回呼函數給 <a class="reference internal" href="#pickle.Pickler" title="pickle.Pickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Pickler</span></code></a>（或 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> 或 <a class="reference internal" href="#pickle.dumps" title="pickle.dumps"><code class="xref py py-func docutils literal notranslate"><span class="pre">dumps()</span></code></a> 函數）的 <em>buffer_callback</em> 引數，使每次生成 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 時，該物件在處理物件圖時能被呼叫。除了一個簡易標記以外，由 <em>buffer_callback</em> 累積的緩衝區資料不會被複製到 pickle 串流中。</p>
<p>接收端需要傳遞一個緩衝區物件給 <a class="reference internal" href="#pickle.Unpickler" title="pickle.Unpickler"><code class="xref py py-class docutils literal notranslate"><span class="pre">Unpickler</span></code></a>（或 <a class="reference internal" href="#pickle.load" title="pickle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a> 或 <a class="reference internal" href="#pickle.loads" title="pickle.loads"><code class="xref py py-func docutils literal notranslate"><span class="pre">loads()</span></code></a> 函式）的 <em>buffers</em> 引數。該物件須是一個可疊代的（iterable）緩衝區（buffer）物件，其中包含傳遞給 <em>buffer_callback</em> 的緩衝區物件。這個可疊代物件的緩衝區順序應該與它們當初被封裝時傳遞給 <em>buffer_callback</em> 的順序相同。這些緩衝區將提供物件重建所需的資料，以使重建器能還原出那個當時產生了 <a class="reference internal" href="#pickle.PickleBuffer" title="pickle.PickleBuffer"><code class="xref py py-class docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a> 的物件。</p>
<p>在傳送與接收端之間，通訊系統可以自由實作轉移帶外緩衝區資料的機制。該機制可能可以利用共用記憶體機制或根據資料類型特定的壓縮方式來最佳化執行速度。</p>
</section>
<section id="example">
<h3>範例<a class="headerlink" href="#example" title="連結到這個標頭">¶</a></h3>
<p>這一個簡單的範例展示了如何實作一個可以參與帶外緩衝區封裝的 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 子類別：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">ZeroCopyByteArray</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__reduce_ex__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">protocol</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">protocol</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">,</span> <span class="p">(</span><span class="n">PickleBuffer</span><span class="p">(</span><span class="bp">self</span><span class="p">),),</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># PickleBuffer 在 pickle 協定 &lt;= 4 時禁止使用。</span>
            <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">_reconstruct</span><span class="p">,</span> <span class="p">(</span><span class="nb">bytearray</span><span class="p">(</span><span class="bp">self</span><span class="p">),)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_reconstruct</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">memoryview</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">as</span> <span class="n">m</span><span class="p">:</span>
            <span class="c1"># 取得對原始緩衝區物件的控制</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">obj</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
                <span class="c1"># 若原本的緩衝區物件是 ZeroCopyByteArray，則直接回傳。</span>
                <span class="k">return</span> <span class="n">obj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
</pre></div>
</div>
<p>如果型別正確，重建器（<code class="docutils literal notranslate"><span class="pre">_reconstruct</span></code> 類別方法）會返回當時提供緩衝區的物件。這個簡易實作可以模擬一個無複製行為的重建器。</p>
<p>在使用端，我們可以用一般的方式封裝這些物件，當我們拆封時會得到一個原始物件的副本：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">ZeroCopyByteArray</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">new_b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># False: 曾進行過複製運算</span>
</pre></div>
</div>
<p>但如果我們傳一個 <em>buffer_callback</em> 並在去序列化時正確返回積累的緩衝資料，我們就能拿回原始的物件：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="n">b</span> <span class="o">=</span> <span class="n">ZeroCopyByteArray</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;abc&quot;</span><span class="p">)</span>
<span class="n">buffers</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">protocol</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">buffer_callback</span><span class="o">=</span><span class="n">buffers</span><span class="o">.</span><span class="n">append</span><span class="p">)</span>
<span class="n">new_b</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">buffers</span><span class="o">=</span><span class="n">buffers</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True</span>
<span class="nb">print</span><span class="p">(</span><span class="n">b</span> <span class="ow">is</span> <span class="n">new_b</span><span class="p">)</span>  <span class="c1"># True: 沒有進行過複製</span>
</pre></div>
</div>
<p>此範例是因為受限於 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 會自行分配記憶體：您無法創建以其他物件的記憶體為基礎的 <a class="reference internal" href="stdtypes.html#bytearray" title="bytearray"><code class="xref py py-class docutils literal notranslate"><span class="pre">bytearray</span></code></a> 實例。不過第三方資料型態（如 NumPy 陣列）則可能沒有這個限制，而允許在不同程序或系統之間傳輸資料時使用零拷貝封裝（或儘可能地減少拷貝次數）。</p>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<p><span class="target" id="index-17"></span><a class="pep reference external" href="https://peps.python.org/pep-0574/"><strong>PEP 574</strong></a> -- 第 5 版 Pickle 協定的帶外資料（out-of-band data）處裡</p>
</div>
</section>
</section>
<section id="restricting-globals">
<span id="pickle-restrict"></span><h2>限制全域物件<a class="headerlink" href="#restricting-globals" title="連結到這個標頭">¶</a></h2>
<p id="index-9">預設情況下，拆封過程將會引入任何在 pickle 資料中找到的類別或函式。對於許多應用程式來說，這種行為是不可接受的，因為它讓拆封器能夠引入並執行任意程式碼。請參見以下 pickle 資料流在載入時的行為：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">pickle</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pickle</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="go">hello world</span>
<span class="go">0</span>
</pre></div>
</div>
<p>在這個例子中，拆封器會引入 <a class="reference internal" href="os.html#os.system" title="os.system"><code class="xref py py-func docutils literal notranslate"><span class="pre">os.system()</span></code></a> 函式，然後執行命令「echo hello world」。雖然這個例子是無害的，但不難想像可以這個方式輕易執行任意可能對系統造成損害的命令。</p>
<p>基於以上原因，您可能會希望透過自訂 <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.find_class()</span></code></a> 來控制哪些是能夠被拆封的內容。與其名稱字面意義暗示的不同，實際上每當你請求一個全域物件（例如，類別或函式）時，就會調用 <a class="reference internal" href="#pickle.Unpickler.find_class" title="pickle.Unpickler.find_class"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Unpickler.find_class()</span></code></a>。因此，可以透過這個方法完全禁止全域物件或將其限制在安全的子集合。</p>
<p>以下是一個僅允許從 <a class="reference internal" href="builtins.html#module-builtins" title="builtins: The module that provides the built-in namespace."><code class="xref py py-mod docutils literal notranslate"><span class="pre">builtins</span></code></a> 模組中載入少數安全類別的拆封器（unpickler）的例子：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">builtins</span>
<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="n">safe_builtins</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;range&#39;</span><span class="p">,</span>
    <span class="s1">&#39;complex&#39;</span><span class="p">,</span>
    <span class="s1">&#39;set&#39;</span><span class="p">,</span>
    <span class="s1">&#39;frozenset&#39;</span><span class="p">,</span>
    <span class="s1">&#39;slice&#39;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">RestrictedUnpickler</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">Unpickler</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">find_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># 只允許幾個內建的安全類別</span>
        <span class="k">if</span> <span class="n">module</span> <span class="o">==</span> <span class="s2">&quot;builtins&quot;</span> <span class="ow">and</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">safe_builtins</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">builtins</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="c1"># 完全禁止任何其他類別</span>
        <span class="k">raise</span> <span class="n">pickle</span><span class="o">.</span><span class="n">UnpicklingError</span><span class="p">(</span><span class="s2">&quot;global &#39;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">&#39; is forbidden&quot;</span> <span class="o">%</span>
                                     <span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">name</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">restricted_loads</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;一個模擬 pickle.loads() 的輔助函數&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">RestrictedUnpickler</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">BytesIO</span><span class="p">(</span><span class="n">s</span><span class="p">))</span><span class="o">.</span><span class="n">load</span><span class="p">()</span>
</pre></div>
</div>
<p>我們剛才實作的的拆封器範例正常運作的樣子：:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="n">pickle</span><span class="o">.</span><span class="n">dumps</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">15</span><span class="p">)]))</span>
<span class="go">[1, 2, range(0, 15)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="sa">b</span><span class="s2">&quot;cos</span><span class="se">\n</span><span class="s2">system</span><span class="se">\n</span><span class="s2">(S&#39;echo hello world&#39;</span><span class="se">\n</span><span class="s2">tR.&quot;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">pickle.UnpicklingError</span>: <span class="n">global &#39;os.system&#39; is forbidden</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">restricted_loads</span><span class="p">(</span><span class="sa">b</span><span class="s1">&#39;cbuiltins</span><span class="se">\n</span><span class="s1">eval</span><span class="se">\n</span><span class="s1">&#39;</span>
<span class="gp">... </span>                 <span class="sa">b</span><span class="s1">&#39;(S</span><span class="se">\&#39;</span><span class="s1">getattr(__import__(&quot;os&quot;), &quot;system&quot;)&#39;</span>
<span class="gp">... </span>                 <span class="sa">b</span><span class="s1">&#39;(&quot;echo hello world&quot;)</span><span class="se">\&#39;\n</span><span class="s1">tR.&#39;</span><span class="p">)</span>
<span class="gt">Traceback (most recent call last):</span>
<span class="w">  </span><span class="c">...</span>
<span class="gr">pickle.UnpicklingError</span>: <span class="n">global &#39;builtins.eval&#39; is forbidden</span>
</pre></div>
</div>
<p>正如我們的範例所示，必須謹慎審視能被拆封的內容。因此，如果您的應用場景非常關心安全性，您可能需要考慮其他選擇，例如 <a class="reference internal" href="xmlrpc.client.html#module-xmlrpc.client" title="xmlrpc.client: XML-RPC client access."><code class="xref py py-mod docutils literal notranslate"><span class="pre">xmlrpc.client</span></code></a> 中的 marshalling API 或其他第三方解決方案。</p>
</section>
<section id="performance">
<h2>效能<a class="headerlink" href="#performance" title="連結到這個標頭">¶</a></h2>
<p>較近期的 pickle 協定版本（從 2 版協定開始）為多種常見功能和內建型別提供了高效率的二進位編碼。此外，<a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 模組還具備一個透明化的、以 C 語言編寫的最佳化工具。</p>
</section>
<section id="examples">
<span id="pickle-example"></span><h2>範例<a class="headerlink" href="#examples" title="連結到這個標頭">¶</a></h2>
<p>最簡單的使用方式，調用 <a class="reference internal" href="#pickle.dump" title="pickle.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">dump()</span></code></a> 和 <a class="reference internal" href="#pickle.load" title="pickle.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">load()</span></code></a> 函式。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="c1"># 任意 pickle 支援的物件。</span>
<span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">],</span>
    <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="p">(</span><span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="sa">b</span><span class="s2">&quot;byte string&quot;</span><span class="p">),</span>
    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="p">{</span><span class="kc">None</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># 使用可用的最高協定來封裝 &#39;data&#39; 字典。</span>
    <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>
</pre></div>
</div>
<p>以下範例可以讀取前述程式所封裝的 pickle 資料。:</p>
<div class="highlight-python3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">pickle</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s1">&#39;data.pickle&#39;</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="c1"># 會自動檢測資料使用的協定版本，因此我們不需要手動指定。</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">也參考</p>
<dl class="simple">
<dt><a class="reference internal" href="copyreg.html#module-copyreg" title="copyreg: Register pickle support functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code></a> 模組</dt><dd><p>註冊擴充型別的 Pickle 介面建構子。</p>
</dd>
<dt><a class="reference internal" href="pickletools.html#module-pickletools" title="pickletools: Contains extensive comments about the pickle protocols and pickle-machine opcodes, as well as some useful functions."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickletools</span></code></a> 模組</dt><dd><p>用於分析或處裡被封裝資料的工具。</p>
</dd>
<dt><a class="reference internal" href="shelve.html#module-shelve" title="shelve: Python object persistence."><code class="xref py py-mod docutils literal notranslate"><span class="pre">shelve</span></code></a> 模組</dt><dd><p>索引式資料庫；使用 <a class="reference internal" href="#module-pickle" title="pickle: Convert Python objects to streams of bytes and back."><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code></a> 實作。</p>
</dd>
<dt><a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> 模組</dt><dd><p>物件的淺層或深度拷貝。</p>
</dd>
<dt><a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 模組</dt><dd><p>內建型別的高效能序列化。</p>
</dd>
</dl>
</div>
<p class="rubric">註解</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="id7" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>不要將此模組與 <a class="reference internal" href="marshal.html#module-marshal" title="marshal: Convert Python objects to streams of bytes and back (with different constraints)."><code class="xref py py-mod docutils literal notranslate"><span class="pre">marshal</span></code></a> 模組混淆</p>
</aside>
<aside class="footnote brackets" id="id8" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">2</a><span class="fn-bracket">]</span></span>
<p>這就是為什麼 <a class="reference internal" href="../reference/expressions.html#lambda"><code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code></a> 函式無法被封裝：所有 <code class="xref std std-keyword docutils literal notranslate"><span class="pre">lambda</span></code> 函式共享相同的名稱：<code class="docutils literal notranslate"><span class="pre">&lt;lambda&gt;</span></code>。</p>
</aside>
<aside class="footnote brackets" id="id9" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id4">3</a><span class="fn-bracket">]</span></span>
<p>拋出的例外應該是 <a class="reference internal" href="exceptions.html#ImportError" title="ImportError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">ImportError</span></code></a> 或 <a class="reference internal" href="exceptions.html#AttributeError" title="AttributeError"><code class="xref py py-exc docutils literal notranslate"><span class="pre">AttributeError</span></code></a>，但也可能是其他例外。</p>
</aside>
<aside class="footnote brackets" id="id10" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id5">4</a><span class="fn-bracket">]</span></span>
<p><a class="reference internal" href="copy.html#module-copy" title="copy: Shallow and deep copy operations."><code class="xref py py-mod docutils literal notranslate"><span class="pre">copy</span></code></a> 模組使用此協定進行淺層及深層複製操作。</p>
</aside>
<aside class="footnote brackets" id="id11" role="doc-footnote">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id6">5</a><span class="fn-bracket">]</span></span>
<p>協定 0 中限制僅能使用英文字母或數字字元來分配持久化 ID 是因為持久化 ID 是由換行符號所分隔的。因此，如果持久化 ID 中出現任何形式的換行字元，將導致封裝資料變得無法讀取。</p>
</aside>
</aside>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="../contents.html">目錄</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python 物件序列化</a><ul>
<li><a class="reference internal" href="#relationship-to-other-python-modules">和其他 Python 模組的關係</a><ul>
<li><a class="reference internal" href="#comparison-with-marshal">和 <code class="docutils literal notranslate"><span class="pre">marshal</span></code> 的比較</a></li>
<li><a class="reference internal" href="#comparison-with-json">和 <code class="docutils literal notranslate"><span class="pre">json</span></code> 的比較</a></li>
</ul>
</li>
<li><a class="reference internal" href="#data-stream-format">資料串流格式</a></li>
<li><a class="reference internal" href="#module-interface">模組介面</a><ul>
<li><a class="reference internal" href="#pickle.HIGHEST_PROTOCOL"><code class="docutils literal notranslate"><span class="pre">HIGHEST_PROTOCOL</span></code></a></li>
<li><a class="reference internal" href="#pickle.DEFAULT_PROTOCOL"><code class="docutils literal notranslate"><span class="pre">DEFAULT_PROTOCOL</span></code></a></li>
<li><a class="reference internal" href="#pickle.dump"><code class="docutils literal notranslate"><span class="pre">dump()</span></code></a></li>
<li><a class="reference internal" href="#pickle.dumps"><code class="docutils literal notranslate"><span class="pre">dumps()</span></code></a></li>
<li><a class="reference internal" href="#pickle.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#pickle.loads"><code class="docutils literal notranslate"><span class="pre">loads()</span></code></a></li>
<li><a class="reference internal" href="#pickle.PickleError"><code class="docutils literal notranslate"><span class="pre">PickleError</span></code></a></li>
<li><a class="reference internal" href="#pickle.PicklingError"><code class="docutils literal notranslate"><span class="pre">PicklingError</span></code></a></li>
<li><a class="reference internal" href="#pickle.UnpicklingError"><code class="docutils literal notranslate"><span class="pre">UnpicklingError</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler"><code class="docutils literal notranslate"><span class="pre">Pickler</span></code></a><ul>
<li><a class="reference internal" href="#pickle.Pickler.dump"><code class="docutils literal notranslate"><span class="pre">dump()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.persistent_id"><code class="docutils literal notranslate"><span class="pre">persistent_id()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.dispatch_table"><code class="docutils literal notranslate"><span class="pre">dispatch_table</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.reducer_override"><code class="docutils literal notranslate"><span class="pre">reducer_override()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Pickler.fast"><code class="docutils literal notranslate"><span class="pre">fast</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pickle.Unpickler"><code class="docutils literal notranslate"><span class="pre">Unpickler</span></code></a><ul>
<li><a class="reference internal" href="#pickle.Unpickler.load"><code class="docutils literal notranslate"><span class="pre">load()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Unpickler.persistent_load"><code class="docutils literal notranslate"><span class="pre">persistent_load()</span></code></a></li>
<li><a class="reference internal" href="#pickle.Unpickler.find_class"><code class="docutils literal notranslate"><span class="pre">find_class()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#pickle.PickleBuffer"><code class="docutils literal notranslate"><span class="pre">PickleBuffer</span></code></a><ul>
<li><a class="reference internal" href="#pickle.PickleBuffer.raw"><code class="docutils literal notranslate"><span class="pre">raw()</span></code></a></li>
<li><a class="reference internal" href="#pickle.PickleBuffer.release"><code class="docutils literal notranslate"><span class="pre">release()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li><a class="reference internal" href="#what-can-be-pickled-and-unpickled">哪些物件能或不能被封裝、拆封？</a></li>
<li><a class="reference internal" href="#pickling-class-instances">Pickling 類別實例</a><ul>
<li><a class="reference internal" href="#object.__getnewargs_ex__"><code class="docutils literal notranslate"><span class="pre">__getnewargs_ex__()</span></code></a></li>
<li><a class="reference internal" href="#object.__getnewargs__"><code class="docutils literal notranslate"><span class="pre">__getnewargs__()</span></code></a></li>
<li><a class="reference internal" href="#object.__getstate__"><code class="docutils literal notranslate"><span class="pre">__getstate__()</span></code></a></li>
<li><a class="reference internal" href="#object.__setstate__"><code class="docutils literal notranslate"><span class="pre">__setstate__()</span></code></a></li>
<li><a class="reference internal" href="#object.__reduce__"><code class="docutils literal notranslate"><span class="pre">__reduce__()</span></code></a></li>
<li><a class="reference internal" href="#object.__reduce_ex__"><code class="docutils literal notranslate"><span class="pre">__reduce_ex__()</span></code></a></li>
<li><a class="reference internal" href="#persistence-of-external-objects">外部物件持久化</a></li>
<li><a class="reference internal" href="#dispatch-tables">調度表</a></li>
<li><a class="reference internal" href="#handling-stateful-objects">處裡紀錄大量狀態的物件</a></li>
</ul>
</li>
<li><a class="reference internal" href="#custom-reduction-for-types-functions-and-other-objects">針對型別、函數或特定物件定製縮減函數</a></li>
<li><a class="reference internal" href="#out-of-band-buffers">帶外（Out-of-band）資料緩衝區</a><ul>
<li><a class="reference internal" href="#provider-api">供給者 API</a></li>
<li><a class="reference internal" href="#consumer-api">消費者 API</a></li>
<li><a class="reference internal" href="#example">範例</a></li>
</ul>
</li>
<li><a class="reference internal" href="#restricting-globals">限制全域物件</a></li>
<li><a class="reference internal" href="#performance">效能</a></li>
<li><a class="reference internal" href="#examples">範例</a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>上個主題</h4>
    <p class="topless"><a href="persistence.html"
                          title="上一章">資料持久性 (Data Persistence)</a></p>
  </div>
  <div>
    <h4>下個主題</h4>
    <p class="topless"><a href="copyreg.html"
                          title="下一章"><code class="xref py py-mod docutils literal notranslate"><span class="pre">copyreg</span></code> --- 註冊 <code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> 支援函式</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>此頁面</h3>
    <ul class="this-page-menu">
      <li><a href="../bugs.html">回報錯誤</a></li>
      <li>
        <a href="https://github.com/python/cpython/blob/main/Doc/library/pickle.rst"
            rel="nofollow">顯示原始碼
        </a>
      </li>
    </ul>
  </div>
        </div>
<div id="sidebarbutton" title="收合側邊欄">
<span>«</span>
</div>

      </div>
      <div class="clearer"></div>
    </div>  
    <div class="related" role="navigation" aria-label="Related">
      <h3>瀏覽</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="總索引"
             >索引</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python 模組索引"
             >模組</a> |</li>
        <li class="right" >
          <a href="copyreg.html" title="copyreg --- 註冊 pickle 支援函式"
             >下一頁</a> |</li>
        <li class="right" >
          <a href="persistence.html" title="資料持久性 (Data Persistence)"
             >上一頁</a> |</li>

          <li><img src="../_static/py.svg" alt="Python logo" style="vertical-align: middle; margin-top: -1px"/></li>
          <li><a href="https://www.python.org/">Python</a> &#187;</li>
          <li class="switchers">
            <div class="language_switcher_placeholder"></div>
            <div class="version_switcher_placeholder"></div>
          </li>
          <li>
              
          </li>
    <li id="cpython-language-and-version">
      <a href="../index.html">3.13.1 Documentation</a> &#187;
    </li>

          <li class="nav-item nav-item-1"><a href="index.html" >Python 標準函式庫 (Standard Library)</a> &#187;</li>
          <li class="nav-item nav-item-2"><a href="persistence.html" >資料持久性 (Data Persistence)</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href=""><code class="xref py py-mod docutils literal notranslate"><span class="pre">pickle</span></code> --- Python 物件序列化</a></li>
                <li class="right">
                    

    <div class="inline-search" role="search">
        <form class="inline-search" action="../search.html" method="get">
          <input placeholder="快速搜尋" aria-label="快速搜尋" type="search" name="q" id="search-box" />
          <input type="submit" value="前往" />
        </form>
    </div>
                     |
                </li>
            <li class="right">
<label class="theme-selector-label">
    Theme
    <select class="theme-selector" oninput="activateTheme(this.value)">
        <option value="auto" selected>Auto</option>
        <option value="light">Light</option>
        <option value="dark">Dark</option>
    </select>
</label> |</li>
            
      </ul>
    </div>  
    <div class="footer">
    &copy; 
      <a href="../copyright.html">
    
    版權
    
      </a>
     2001-2024, Python Software Foundation.
    <br />
    This page is licensed under the Python Software Foundation License Version 2.
    <br />
    Examples, recipes, and other code in the documentation are additionally licensed under the Zero Clause BSD License.
    <br />
    
      See <a href="/license.html">History and License</a> for more information.<br />
    
    
    <br />

    The Python Software Foundation is a non-profit corporation.
<a href="https://www.python.org/psf/donations/">Please donate.</a>
<br />
    <br />
      最後更新於 12月 07, 2024 (13:18 UTC)。
    
      <a href="/bugs.html">Found a bug</a>?
    
    <br />

    使用 <a href="https://www.sphinx-doc.org/">Sphinx</a> 8.1.3 建立。
    </div>

  </body>
</html>